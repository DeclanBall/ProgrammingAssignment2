## Put comments here that give an overall description of what your
## functions do
##The following function creates a "special" matrix that has the ability to cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
specialmatrix <- NULL
set <- function(y) {
x <<- y                         ## assigns y to x in a seperate environment
specialmatrix <<- NULL          ## assigns NULL to specialmatrix in a seperate environment
}
get <- function() x
setmatrix <- function(solve) specialmatrix <<- solve
getmatrix <- function() specialmatrix
list(set = set, get = get, setmatrix = setmatrix, getmatrix = getmatrix)
}
## The following function will first check to see if the inverse of the "set" matrix has already
## been calculated, if it has then it will "get" the result from the cache. If not then it will
## compute the inverse and cache it.
cacheSolve <- function(x, ...) {
specialmatrix <- x$getmatrix()           ## So this section will seek to return a cached
if(!is.null(specialmatrix)) {            ## solution for the inverse of the matrix
message("getting cached")              ## as long as the solution does not return a
return(specialmatrix)                  ## NULL response.
}
matrix <- x$get()                       ## Should a NULL response be the case, this section
specialmatrix <- solve(matrix, ...)     ## will compute the inverse, cache the result using
x$setmatrix(specialmatrix)               ## x$setmatrix and return the result.
specialmatrix
}
makeCacheMatrix()
z <- matrix(1:16, 4, 4)
z
cacheSolve(z)
cacheSolve(z)
makeCacheMatrix(z
makeCacheMatrix(z)
makeCacheMatrix
## Put comments here that give an overall description of what your
## functions do
##The following function creates a "special" matrix that has the ability to cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
specialmatrix <- NULL
set <- function(y) {
x <<- y                         ## assigns y to x in a seperate environment
specialmatrix <<- NULL          ## assigns NULL to specialmatrix in a seperate environment
}
get <- function() x
setinverse <- function(solve) specialmatrix <<- solve
getinverse <- function() specialmatrix
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
## The following function will first check to see if the inverse of the "set" matrix has already
## been calculated, if it has then it will "get" the result from the cache. If not then it will
## compute the inverse and cache it.
cacheSolve <- function(x, ...) {
specialmatrix <- x$getinverse()          ## So this section will seek to return a cached
if(!is.null(specialmatrix)) {            ## solution for the inverse of the matrix
message("getting cached data")         ## as long as the solution does not return a
return(specialmatrix)                  ## NULL response.
}
matrix <- x$get()                       ## Should a NULL response be the case, this section
specialmatrix <- solve(matrix, ...)     ## will compute the inverse, cache the result using
x$setinverse(specialmatrix)             ## x$setmatrix and return the result.
specialmatrix
}
makeCacheMatrix(x)
x <- matrix(1:16, 4, 4)
makeCacheMatrix(x)
clear()
wipe
solve(x)
x
class(x)
solve(x)
makeCacheMatrix()
inverse(x)
?solve
## Put comments here that give an overall description of what your
## functions do
##The following function creates a "special" matrix that has the ability to cache its inverse.
makeCacheMatrix <- function(x = matrix()) {
specialmatrix <- NULL
set <- function(y) {
x <<- y                         ## assigns y to x in a seperate environment
specialmatrix <<- NULL          ## assigns NULL to specialmatrix in a seperate environment
}
get <- function() x
setinverse <- function(solve) specialmatrix <<- solve
getinverse <- function() specialmatrix
list(set = set, get = get, setinverse = setinverse, getinverse = getinverse)
}
## The following function will first check to see if the inverse of the "set" matrix has already
## been calculated, if it has then it will "get" the result from the cache. If not then it will
## compute the inverse and cache it.
cacheSolve <- function(x, ...) {
specialmatrix <- x$getinverse()          ## So this section will seek to return a cached
if(!is.null(specialmatrix)) {            ## solution for the inverse of the matrix
message("getting cached data")         ## as long as the solution does not return a
return(specialmatrix)                  ## NULL response.
}
matrixdata <- x$get()                       ## Should a NULL response be the case, this section
specialmatrix <- solve(matrixdata, ...)     ## will compute the inverse, cache the result using
x$setinverse(specialmatrix)             ## x$setmatrix and return the result.
specialmatrix
}
x = rbind(c(1, -1/4), c(-1/4, 1))
m = makeCacheMatrix(x)
m$get()
cachesolve(x)
cacheSolve(x)
cacheSolve(m)
makeCacheMatrix(x)
x = rbind(c(1, -1/4), c(-1/4, 1))
makeCacheMatrix(x)
cacheSolve(m)
cacheSolve(m)
cacheSolve(m)
